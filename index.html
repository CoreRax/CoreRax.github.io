<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-新学的一点JS技巧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/新学的一点JS技巧/" class="article-date">
  <time datetime="2018-06-30T13:26:29.330Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/新学的一点JS技巧/">分享一个JS技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天要做一个功能，需要将页面的电话号码拿到后台去查询，返回其他列表。页面的电话号码数量多，并且有很多重复，需要做去重。  </p>
<p>使用js可以很简单的实现去重功能。  </p>
<p>JS可以对象可以动态添加属性，新建一个空对象，将号码作为属性加到对象中，属性值可以赋值为true或者其他。这是如果有其他相同的号码添加到对象中，因为对象名相同，只会覆盖原有的属性。当把所有的号码都添加到对象中，最后，对象中留下的属性名，就是没有重复的号码了。这时就可以将这个对象转换成字符串传到后台处理了。 </p>
<pre><code>function noDuplicate(){
    var numbList = {.....};
    var obj = {};
    for (num in numbList){
        obj[num] = true;
    }
    return obj;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/30/新学的一点JS技巧/" data-id="cjj1fz1kb000ks0heh37covbw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基于手机解锁的智能锁设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/基于手机解锁的智能锁设计/" class="article-date">
  <time datetime="2018-06-30T13:26:29.326Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/30/基于手机解锁的智能锁设计/" data-id="cjj1fz1ic0000s0heddoc946x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-关于邮件附件名为中文时的问题处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/关于邮件附件名为中文时的问题处理/" class="article-date">
  <time datetime="2018-06-30T13:26:29.324Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/关于邮件附件名为中文时的问题处理/">邮件附件名为中文时收到的邮件附件为tcmime.XXXX.XXXX.XXXX.bin</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>在使用JavaMail发送带附件邮件时</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>Class MimeUtility.encodeWord<br>MimeUtility提供了一系列的MIME头编解码方法。<br>一个遵循RFC 822的邮件头<strong>必须</strong>包含只含只由US-ASCII 字符集构成的字串，如果不是US-ASCII 的字符必需被编码来只含有US-ASCII 字符。这一过程涉及使用Base64或者QP来编码。</p>
<p>在Java中，字符串包含unicode字符，ASCII是Unicode的子集(0-127),一个只包含ASCII编码的字符串已经是“邮件安全”的了。如果字符串包含非ASCII编码的字符，那就必须要被编码过。</p>
<p>记住，如果要安全地得到邮件的字符串的字节码，需要用一下方法：<br><code>byte[] bytes = string.getBytes(&quot;iso-8859-1&quot;);</code></p>
<p>MimeUtility.encodeWord方法说明：<br>把一个RFC 822规范的字串编码为”邮件安全”的per RFC2047规范要求的字串。<br>给定的参数以一个含有非ASCII字符的字串，如果含有ASCII字符，该字符就会保持原样，如果有非ASCII字符，首先会使用平台默认的编码格式，然后使用BASE64或者QP进行传输编码。返回的字符串就是只包含ASCII字符的字串。</p>
<p>使用方法，在添加附件的时候是使用的<code>MimeMessageHelper.addAttachment(filename,file)</code>这时在使用filename的之前先使用<code>MimeUtility.encodeWord(fileName, MimeUtility.getDefaultJavaCharset(),&quot;B&quot;)</code>编码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/30/关于邮件附件名为中文时的问题处理/" data-id="cjj1fz1k4000gs0heogf1hobh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spark入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/Spark入门/" class="article-date">
  <time datetime="2018-06-30T13:26:29.320Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>什么是spark</strong><br>是一个大数据处理框架，以速度，易用性，复杂性分析为目的构建的。是Apache的开源项目之一。<br><strong>优势</strong><br>相比其他大数据框架相比优势如下  </p>
<p><strong>外部数据集</strong><br>Spark可以在任何Hadoop支持的存储源里创建分布式数据集，这些存储源包括本地文件系统，HDFS，Cassandra, HBase, Amazon S3等。Spark支持文本文件，序列文件，和其他Hadoop支持的输入格式。</p>
<p>文本类型弹性分布式数据集可以使用SparkContext中的textFile方法创建。这个方法把一个URI当成一个文件，并且当成一个行的集合来读取。  </p>
<pre><code>JavaRDD&lt;String&gt; distFile = sc.textFile(&quot;data.txt&quot;);  
</code></pre><p>一旦创建分布式数据集，distFile对象就可以被用来做一些数据集操作。比如我们可以使用map和reduce来计算所有行的长度之和：</p>
<pre><code>distFile.map(s-&gt;s.length()).reduce((a,b) -&gt;a+b)  
</code></pre><p> Spark读取文件注意事项：  </p>
<ul>
<li>如果你使用的是在本地文件系统上的路径，文件必须是在工作节点上相同的路径并且可以访问的。不管是复制到所有工作节点还是使用网络共享文件系统。  </li>
<li>Spark的所有基于文件的输入方法，包括textFile，支持运行在目录上，压缩文件上，还有通配符。比如可以使用textFile(“/my/directory”), textFile(“/my/directory/<em>.txt”), and textFile(“/my/directory/</em>.gz”)   </li>
<li>textFile方法也有一个可选的第二参数老控制文件被分为多少部分。默认的Spark为每一块文件创建一个分区（块在HDFS中默认是64MB）,可以请求更大数目的分区，但不能少于块数。  </li>
</ul>
<p>除了文本文件格式，Spark的Java API也支持其他几个数据格式：   </p>
<ul>
<li>JavaSparkContext.wholeTextFiles允许你读取一个包含多种文本格式的目录，然后将这些文件按（文件名，内容）对的形式返回。这和textFile在每一个文件中返回每一行的一个记录相反。  </li>
<li>对于流式文件，使用SparkContext的sequenceFile[k,v]方法。其中k和v分别是类型的键和文件的值。这些应该继承Hadoop的Writable接口，比如intWritable和Text。除此之外，Spark允许你为几个常用的Writable接口本地指定类型，比如sequenceFile[int, String]将自动的读取IntWritables 和 Texts。</li>
<li>对于其他的Hadoop输入类型，你可以使用SparkContext.HadoopRDD方法，它可以获取任意的JobConf，输入类型类，键类和值类。你也可以使用SparkContext.newAPIHadoopRDD来支持基于新的MapReduce API的输入格式。</li>
<li>RDD.saveAsObjectFile和SparkContext.objectFile支持将一个RDD存储为一个简单的包含序列化的Java对象的格式。虽然这对于一些特别的格式比如Avro效率不高，但是提供了一个简单的方法来存储RDD。</li>
</ul>
<p><strong>RDD操作</strong><br>RDD支持两种类型的操作:transformations（变换）它从已经存在的RDD创建一个新的数据集；action（活动/行动）它在数据集上做好运算之后返回一个值给驱动程序。比如，map是一个transformation，它通过一个函数传递每个数据集元素，并且返回一个新的RDD代表结果。另一方面，reduce是一个action它使用某种方法聚集所有的RDD的元素并且返回一个最后的结果给驱动程序（虽然也有一个并行的ruduceByKey它返回分布式数据集）。<br>Spark中所有的transformations是懒惰的/消极的,他们不会立即计算他们的结果。相反他们仅仅记录transformations应用到一些基本的数据集。transformations仅仅在action请求一个结果返回到驱动程序的时候才会计算。这个设计使得Spark运行更加高效，比如我们意识到一个被map创建的数据集将会被用于reduce并且仅仅返回reduce的结果给驱动程序。而不是一个更大的映射数据数据集。//不太明白<br>默认的，每一个变换过后的RDD在每一次你运行action的时候可能被重新计算。然而你可能也存留着一个RDD在内存中通过使用persist或者cache方法，在这种情况下Spark将会保留这些元素在节点中以便下一次你查询的时候更加快速的连接。这也支持在硬盘中的持久化的RDD，或者在多个节点中重复的。  </p>
<p><strong>基础</strong><br>为了举例说明RDD的基本知识，考虑下列简单的程序：  </p>
<pre><code>JavaRDD&lt;String&gt; lines = sc.textFile(&quot;data.txt&quot;);
JavaRdd&lt;String&gt; lineLengths =  lines.map(s-&gt;s.length());
int totalLength = lineLengths.reduce((a,b) -&gt; a+b);
</code></pre><p>第一行从一个外部文件中定义了一个基本的RDD(弹性分布式数据集)。这个数据集现在还没有加载到内存，或者开始处理：lines仅仅是一个指向文件的指针。第二行定义了lineLengths作为一个map transformation的结果。同样的，lineLengths并没有被立即运算，因为它是懒惰性质的。最后运行reduce，它是一个action。这时候Spark将计算任务打散成task来在不同的机器上运行。每个机器运行它那一部分map和本地reduction，返回自己的结果到驱动程序。<br>如果之后还需要使用lineLengths，我们可以添加：  </p>
<pre><code>lineLengths.persist(StorageLevel.MEMORY_ONLY()); 
</code></pre><p>在reduce之前，这可以使得lineLength在第一次计算之前就存储到内存中。</p>
<p><strong>传递Functions给Spark</strong><br>Spark的API很大程度依赖于传递Functions到驱动程序来运行集群。在Java中，Functions由实现org.apache.spark.api.java.function 包中接口的类代表。有两种方法来创建这些functions：   </p>
<ul>
<li>在你的类中实现Function接口，或者作为一个匿名内部类或者有名字的类传递一个实例到Spark。</li>
<li><p>在Java8 中使用lambda表达式来简洁地定义一个实现。<br>当本教程为了简洁大部分使用lambda语法，使用相同的API就很简单。比如我们可以把上面的代码写成：</p>
<pre><code> JavaRDD&lt;String&gt; lines = sc.textFile(&quot;data.txt&quot;);
 JavaRDD&lt;String&gt; lineLengths = lines.map(new Function&lt;Stirng, Integer&gt;(){
 public Integer call(String s){ return s.length();}
 });
 int totalLength = lineLength.reduce(new Function2&lt;Integer, Integer, Integer&gt;() {
 public Integer call(Integer a, Integer b){return a+b;}
});
</code></pre></li>
</ul>
<p>或者，如果觉得吧function写为内联是笨拙的做法：</p>
<pre><code>Class GetLength implements Function&lt;String, Integer&gt; {
     public Integer call(String s) { return s.length(); }
}
class Sum implements Function2&lt;Integer, Integer, Integer&gt; {
public Integer call(Integer a, Integer b) { return a + b; }
}

JavaRDD&lt;String&gt; lines = sc.textFile(&quot;data.txt&quot;);
JavaRDD&lt;Integer&gt; lineLengths = lines.map(new GetLength());
int totalLength = lineLengths.reduce(new Sum());
</code></pre><p>记住匿名内部类在Java中也可以访问闭合区间的变量，只要这些变量是final的。Spark传递这些变量的拷贝给每一个节点。  </p>
<p><strong>理解闭包</strong><br>Spark中比较困难的事是当在集群之间运行代码时理解变量和方法的作用域和生命期。RDD操作很多是在变量的作用域之外改变变量的值，这是一个造成混淆的主要原因。在下面的例子中我们将看到代码使用foreach()来增加计数器，但是相同的问题发生在其他操作中。  </p>
<p>####### 举例 </p>
<p>假设一个RDD元素加和，结果将表现得很不同，取决于运行的在相同的JVM上。一个普通的例子是当在local模式运行Spark和将Spark应用发布到集群上运行。  </p>
<pre><code>int counter = 0;
JavaRDD&lt;Integer&gt; rdd = sc.parallelize(data);

//Wrong:Don&apos;t do this!
rdd.foreach(x-&gt;counter +=x);
println(&quot;Counter value: &quot; + counter);
</code></pre><p>####### Local vs. cluster modes<br>上面代码的表现是无法定义的，可能无法按照预期的运行。为了运行任务，将RDD操作的进程打散成任务，每一个任务都被一个执行者执行。在执行之前，Spark计算任务的<strong>闭包</strong>。闭包是可以被执行RDD上计算任务的执行者可见的变量和方法。这个闭包是序列化的兵器可以送到每一个执行者。  </p>
<p>在闭包中被送到每一个执行者的变量现在是拷贝，因此，当counter被foreach()引用的时候，已经不再只是驱动节点上的counter了。这里任然有一个counter在驱动节点的内存中，但是已经不再对执行者可见了。执行者只能看到序列化闭包中的拷贝。因此，counter最后的值将仍旧是0因为所有的对counter的操作只能影响到序列化闭包中。  </p>
<p>在本地模式中，在一些情况下foreach() function会实际上执行在相同的JVM上并且会引用相同的原始counter，可能会更新它。  </p>
<p>为了确保这些一系列行为被完好定义，应该使用一个Accumulator(累加器)。累加器在Spark中被明确地用来提供一种安全的机制来更新一个变量当执行过程被划分到一个集群中不同的工作节点时。在累加器部分会详细讨论。</p>
<p>一般来说</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/30/Spark入门/" data-id="cjj1fz1k7000is0he9mr11kvl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-QuickSort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/QuickSort/" class="article-date">
  <time datetime="2018-06-30T13:26:29.316Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/QuickSort/">快速排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序可能是运用最广泛的排序算法，主要原因是他实现简单，适用于各种输入数据，并且在一般应用中比其他排序算法快得多。<br>主要特点：原地排序，且将长度为N的数组排序所需时间和NlogN成正比，快速排序内循环比大多数哦爱婿算法都要短小，所以更加快速。<br>主要缺点：非常脆弱，在实际使用中，要非常小心才能避免低劣的性能。  </p>
<p>快速排序是一种分治的排序算法，他将数组分成两个子数组，将两个部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分为两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。归并排序中先归并再排序，快速排序中线排序在归并。  </p>
<p>快速排序的关键在于切分，使得数组满足如下条件：  </p>
<ul>
<li>对于某个j，a[j]已经排定；</li>
<li>a[lo]到a[j-1]中的所有元素都不大于a[j];</li>
<li>a[j+1]到a[hi]中的所有元素都不小于a[i];  </li>
</ul>
<p>因为切分的过程总能排定一个元素，用归纳法可以证明递归能够正确地将数组排序：如果左子元素和右子元素都是有序的，那么由左子元素，切分元素和右子元素组成的结果数组一定是有序的。  </p>
<p>在快速排序中需要实现切分方法。一般策略是先随机地取a[lo]作为切分元素，即那个将要被排定的元素，然后我们从左端开始向右扫描直到找到一个大于等于它的元素，再从数组右边向左开始扫描知道找到一个小于等于它的元素。这两个元素显然没有排定，因此我们交换他们的位置。如此继续就可以保证左指针左侧的元素不大于切分元素，右指针右侧的元素不小于切分元素。当两个指针相遇，我们只需要将切分元素a[lo]和左子数组最右侧的元素a[j]交换然后返回j即可。  </p>
<p>以下是在快速排序中的几个细节问题，因为他们都可能导致实现错误或是影响性能。<br><strong>原地切分</strong><br>如果使用辅助数组将会很容易实现切分，凡是切分后的数组复制回去的开销也会让我们得不偿失。如果将空数组创建在递归方法中，会大大降低排序的性能。<br><strong>别越界</strong><br>如果切分元素是数组中最小或者是最大的元素，我们要小心别然扫描指针抛出数组边界。partition()实现可以进行明确的检测来预防这种情况。测试条件（j==lo）是冗余的，因为切分元素就是a[lo],他不可能比自己小。数组右端也有相同的情况，他们都是可以去掉的。<br><strong>保持随机性</strong><br>数组元素被打乱过，对于预测算法时间很重要。另一种保持随机性的方法就是在partition()方法中随机选择一个切分元素。<br><strong>终止循环</strong><br>有经验的程序员都知道保证循环结束需要格外小心，快速排序的切分循环也不例外。正确地检测指针是否越界需要一点技巧。一个常见的错误就是没有考虑到数组中可能包含和切分元素相同的其他元素。<br><strong>处理切分元素值有重复的情况</strong><br>如算法所示，左侧扫描最好实在遇到大于等于切分元素值得元素时停下，右侧扫描则是遇到小于等于切分元素的值的元素时停下。尽管这样可能会不必要德将一些等值的元素交换，但是在某些典型应用中，他能避免算法的运行时间变为平方级。<br><strong>终止递归</strong><br>保证递归的正确结束也是需要格外小心的，快速排序也不例外，实现快速排序的一个常见错误就是不能保证切分元素放入正确位置，从而导致程序在切分元素正好是子数组的最大或者是最小元素时陷入无限递归循环之中。</p>
<h4 id="性能特点"><a href="#性能特点" class="headerlink" title="性能特点"></a>性能特点</h4><p>快速排序切分方法内循环比其他排序算法短小，只需要用一个递增的索引将数组元素与一个定值比较，简洁的内循环使得算法更加高效。<br>另一个优势在于，比较次数较少，排序效率最终还是依赖于切分数组的效果，而这还是依赖于切分点的值。<br>快速排序最好的情况是每次正好能将数组对半分。在这种情况下快速排序所用的比较次数正好满足分治递归的<code>Cn=2Cn\2+N</code>公式。2Cn/2表示将两个子数组排序的成本，N表示切分元素和所有数组元素进行比较的成本。由归并排序的命题F证明可知，这个递归公式的解Cn~Nlogn.尽管事情进行总不会那么顺利，但是平均而言切分元素都能落在数组中间。<br>尽管快速排序有很多优点，它的基本实现却有一个潜在的缺点，在切分不平衡时这个程序可能会极为低效。例如，第一次从最小的元素切分，第二次从第二小的元素切分，这样每次调用只会移除一个元素。这会导致一个大子数组需要切分很多次。我们要在排序前将数组随机排序主要的原因就是避免这种情况。  </p>
<p>###算法改进<br>如果你的排序算法会被执行很多次，或者会被用在大型数组上，下面这些改进意见值得参考。<br><strong>切换到插入排序</strong><br>和大多数算法改进一样，改进快速排序性能的简单办法基于以下两点：  </p>
<ul>
<li>对于小数组快速排序比插入排序慢  </li>
<li>因为递归，快速排序的sort()在小数组中也会调用自己  </li>
</ul>
<p>将sort()函数中的语句  </p>
<pre><code>if （hi &lt;= lo) return;
</code></pre><p>替换成如下语句来对小数组使用插入排序  </p>
<pre><code>if (hi &lt;= lo +m) {Insertion.sort(a, lo, hi); return;} 
</code></pre><p>转换参数m的最佳值是和系统有关的，但是5~15之间的任何值都能令人满意。  </p>
<p><strong>三取样切分</strong><br>改进快速排序性能的第二个方法就是使用子数组的一小部分元素的中位数来切分数组，但是这样做的代价就是需要计算中位数。人们发现将取样大小设为3并且用大小居中的元素切分的效果更好。我们还可以经取样元素放在数组末尾作为哨兵来去掉partition（）边界测试。  </p>
<p><strong>熵最优的排序</strong><br>实际应用中经常会有大量重复的元素，对于重复的数组，算法还是会进行划分，还有很大的改进空间。一个简单的想法就是将数组切分为三部分，分别对应于小于，等于和大于切分元素的数组元素。这种切分比当前的二分法更加复杂。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/30/QuickSort/" data-id="cjj1fz1k5000hs0hep39ts8si" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Js核心-作用域链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/Js核心-作用域链/" class="article-date">
  <time datetime="2018-06-30T13:26:29.311Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/Js核心-作用域链/">JavaScript作用域链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JavaScript是基于词法作用域的语言，也就是通过阅读包含变量定义在内的源码就能知道变量的作用域。全局变量在程序中始终有定义，局部变量在声明它的函数体内以及所嵌套的函数内都有定义。</p>
<p>全局变量是全局对象的一个属性。虽然没有规定，但是我们可以同样的将局部变量看作是自定义实现的对象的属性。这样每一段JavaScript代码，不论是全局代码或者是函数，都有一个与之相关联的作用域链。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码作用域中的变量。当JavaScript做变量解析的时候，也就是查找某一个名为x的变量的时候，会从作用域链中的第一个对象开始查找，如果这个对象有一个名为x的属性，就会直接使用这个属性的值。如果第一个对象没有名为x的属性，JavaScript会继续查找作用域链上的下一个对象。以此类推。如果作用域链上没有任何一个对象包含属性x，那么这段代码的作用域链上不存在x，并最终抛出一个引用错误（ReferenceError）异常。  </p>
<p>在JavaScript的最外层代码中，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域上有两个对象，一个是定义函数参数和局部变量的对象，另一个是全局对象。</p>
<p>作用域链的创建规则，当定义一个函数时，它实际上保存了一个作用域链，当我们调用这个函数时，它创建一个新的对象来存储它的局部变量，并且把这个对象加到保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/30/Js核心-作用域链/" data-id="cjj1fz1k2000fs0heend3548y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java面试题总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/Java面试题总结/" class="article-date">
  <time datetime="2018-06-30T13:26:29.307Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/Java面试题总结/">Java面试题总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Final-finally-Finalize"><a href="#Final-finally-Finalize" class="headerlink" title="Final,finally,Finalize"></a>Final,finally,Finalize</h3><p>Final是一个修饰符，被他修饰变量将不能再被改变或者指向另一个队对象；被他修饰的对象将不能被继承；被他修饰方法不能被重写。</p>
<p>Finally是用在try…catch块之后，用于执行一些不管发生什么情况都要运行的代码，以安全运行程序。</p>
<p>Finalize是一个继承与java.lang.Object的方法。一旦垃圾回收器准备好释放对象占用的内存，将首先调用对象的Finalize方法，并且在下一次垃圾回收时将对象回收，finalize能让你在对象被回收时做一些重要的清理工作。<br>一般情况下不需要重新覆盖这个方法，因为Object已经有一个默认的实现。但是用Java以外的代码编写的Class（如JNI，C++的new方法分配的内存），垃圾回收机制并不能对这部分对象进行正确的回收，这时就需要覆盖默认的方法来实现对这部分内存的正确释放和回收。比如C++的delete。</p>
<h3 id="并发-如何创建一个线程"><a href="#并发-如何创建一个线程" class="headerlink" title="并发-如何创建一个线程"></a>并发-如何创建一个线程</h3><p>有两种方法，1.是实现Runnable接口，当成一个参数传给Thread构造函数；2.是直接继承Thread类。  </p>
<h3 id="并发-线程的生命周期"><a href="#并发-线程的生命周期" class="headerlink" title="并发-线程的生命周期"></a>并发-线程的生命周期</h3><p>新建一个线程时它的状态是new，调用start()方法以后由new变为runnable，线程调度器会为Runnable线程池中的线程分配CPU时间，并且将状态改为running，调用wait()方法可以编程waiting状态，blocked和Dead。</p>
<h3 id="并发-什么是上下文切换"><a href="#并发-什么是上下文切换" class="headerlink" title="并发-什么是上下文切换"></a>并发-什么是上下文切换</h3><p>上下文切换就是线程的切换，包括存储和回复CPU状态的过程。  </p>
<h3 id="并发-如何确保main-方法在所在的线程最后结束"><a href="#并发-如何确保main-方法在所在的线程最后结束" class="headerlink" title="并发-如何确保main()方法在所在的线程最后结束"></a>并发-如何确保main()方法在所在的线程最后结束</h3><p>我们可是使用Thread类的join()方法来确保所有的程序创建的线程在main()方法结束退出前结束。  </p>
<h3 id="并发-为什么线程通信方法wait-notify-notifyall-被定义在Object类里？"><a href="#并发-为什么线程通信方法wait-notify-notifyall-被定义在Object类里？" class="headerlink" title="并发-为什么线程通信方法wait(),notify(),notifyall()被定义在Object类里？"></a>并发-为什么线程通信方法wait(),notify(),notifyall()被定义在Object类里？</h3><p>Java的每一个对象中都有一个锁（moniter将，也可以成为监视器）并且wait(),notify()等方法用于等待对象锁，或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。  </p>
<h3 id="并发-为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？"><a href="#并发-为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="并发- 为什么wait(), notify()和notifyAll ()必须在同步方法或者同步块中被调用？"></a>并发- 为什么wait(), notify()和notifyAll ()必须在同步方法或者同步块中被调用？</h3><p>当一个线程调用对象的wait()方法时，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并且进入等待状态直到其他线程调用这个对象的notify()方法。同样的，当一个线程线程调用对象的notify()方法时他会释放这个对象的锁，以便其他等待的线程可以得到这个对象的锁。由于所有这些通信方法都需要线程持有对象的锁，这样就只能通过同步来实现，他们只能在同步方法或者同步块中被调用。</p>
<h3 id="为什么Thread类中的sleep-和yied方法是静态的"><a href="#为什么Thread类中的sleep-和yied方法是静态的" class="headerlink" title="为什么Thread类中的sleep()和yied方法是静态的"></a>为什么Thread类中的sleep()和yied方法是静态的</h3><p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程调用这些方法是没有意义的。他们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<h3 id="volatile关键字有什么作用"><a href="#volatile关键字有什么作用" class="headerlink" title="volatile关键字有什么作用"></a>volatile关键字有什么作用</h3><p>确保不同线程中读取到的变量是一样的。</p>
<h3 id="同步块和同步方法哪一个是更好的选择"><a href="#同步块和同步方法哪一个是更好的选择" class="headerlink" title="同步块和同步方法哪一个是更好的选择"></a>同步块和同步方法哪一个是更好的选择</h3><p>同步块是更好的选择，因为它不会锁住整个对象。 </p>
<h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h3><p>ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享他的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步技术的时候，我们可以选择ThreadLocal变量。每个线程都会拥有他们自己的Thread变量，他们可以使用get/set方法来获取他们的默认值或者在线程内部改变他们的值。  </p>
<h3 id="什么是Java-Timer类？如何创建一个特定时间间隔的任务？"><a href="#什么是Java-Timer类？如何创建一个特定时间间隔的任务？" class="headerlink" title="什么是Java Timer类？如何创建一个特定时间间隔的任务？"></a>什么是Java Timer类？如何创建一个特定时间间隔的任务？</h3><p>java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。<br>java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。  </p>
<h3 id="什么是线程池？如何创建线程池？"><a href="#什么是线程池？如何创建线程池？" class="headerlink" title="什么是线程池？如何创建线程池？"></a>什么是线程池？如何创建线程池？</h3><p>一个线程池管理了一组工作线程，同时它还包括一个用于放置等待执行的任务的队列。<br>java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池。  </p>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>接口中所有的方法都是抽象的，类可以同时包括抽象和非抽象方法</li>
<li>类可以实现很多个接口，但是只能继承一个抽象类</li>
<li>类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的</li>
<li>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</li>
<li>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。  </li>
</ul>
<h3 id="什么是值传递，什么是引用传递"><a href="#什么是值传递，什么是引用传递" class="headerlink" title="什么是值传递，什么是引用传递"></a>什么是值传递，什么是引用传递</h3><p>对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。<br>对象呗引用传递，意味着传递的并不是实际对象，而是对象的引用。因为，外部对引用对象的改变都会反映到源对象上。  </p>
<h3 id="Java集合类框架的基本接口有哪些"><a href="#Java集合类框架的基本接口有哪些" class="headerlink" title="Java集合类框架的基本接口有哪些"></a>Java集合类框架的基本接口有哪些</h3><ul>
<li>Collection：代表一组对象，每一个对象都是他的子元素。</li>
<li>Set：不包含重复元素的Collection。</li>
<li>List：可以有重复元素的的有序Collection。</li>
<li>Map：可以把Key映射到value的对象，key不可重复。 </li>
</ul>
<h3 id="为什么集合类没有实现Cloneable和Serializable接口"><a href="#为什么集合类没有实现Cloneable和Serializable接口" class="headerlink" title="为什么集合类没有实现Cloneable和Serializable接口"></a>为什么集合类没有实现Cloneable和Serializable接口</h3><p>集合类接口定义了一组叫做元素的对象，集合类接口的每一种具体的实现类都可以选择它自己的方式对元素进行保存和排序，有的集合类允许重复的键，有的不允许。</p>
<h3 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h3><p>Iterator接口提供了很多对于集合元素进行迭代的方法，每个集合类都包含了可以返回迭代器实例的迭代方法，迭代器可以在迭代的过程中删除底层集合的元素。</p>
<h3 id="Itertor和ListIterator的区别"><a href="#Itertor和ListIterator的区别" class="headerlink" title="Itertor和ListIterator的区别"></a>Itertor和ListIterator的区别</h3><ul>
<li>Iterator可以遍历Set和List集合，但是ListIterator只能用来遍历List。</li>
<li>Iterator只能向后遍历，ListIterator既可以前向也可以后向遍历。</li>
<li>LstIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。  </li>
</ul>
<h3 id="Java中的HashMap的工作原理是什么"><a href="#Java中的HashMap的工作原理是什么" class="headerlink" title="Java中的HashMap的工作原理是什么"></a>Java中的HashMap的工作原理是什么</h3><p>Java中HashMap以键值对的形式来存储元素，HashMap需要一个hash函数，它使用hashcode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法时HashMap会计算key的hash值然后把键值对存储在集合中的合适的索引上。如果key已经存在，value的值会被更新。</p>
<h3 id="HashMap和HashTable有什么区别"><a href="#HashMap和HashTable有什么区别" class="headerlink" title="HashMap和HashTable有什么区别"></a>HashMap和HashTable有什么区别</h3><p>Java中HashTable是jdk 1的时代留下来的产物。  </p>
<ul>
<li>HashMap允许键和值是null，而hashTable不允许。</li>
<li>HashTable是同步的，而HashMap不是，所以HashMap更加适合单线程环境。</li>
</ul>
<h3 id="数组-Arrays-和列表-ArrayList-有什么区别？什么时候应该使用Arrays而不是ArrayList？"><a href="#数组-Arrays-和列表-ArrayList-有什么区别？什么时候应该使用Arrays而不是ArrayList？" class="headerlink" title="数组(Arrays)和列表(ArrayList)有什么区别？什么时候应该使用Arrays而不是ArrayList？"></a>数组(Arrays)和列表(ArrayList)有什么区别？什么时候应该使用Arrays而不是ArrayList？</h3><ul>
<li>数组的大小是固定的，ArrayList的大小是不固定的。</li>
<li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等。</li>
<li>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li>
</ul>
<h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><p>ArrayList和LinkedList都实现了List接口，但是不同点在于：   </p>
<ul>
<li>ArrayList的底层实现是数组，LinkedList的底层实现是链表，因此在对于元素的随机访问时ArrayList的效率更高。  </li>
<li>LinkedList的插入添加删除操作更快。</li>
<li>LinkedList更加占内存，因为每个节点都有两个引用。  </li>
</ul>
<h3 id="Comparable和Comparator接口是干什么的？列出它们的区别。"><a href="#Comparable和Comparator接口是干什么的？列出它们的区别。" class="headerlink" title="Comparable和Comparator接口是干什么的？列出它们的区别。"></a>Comparable和Comparator接口是干什么的？列出它们的区别。</h3><p>Java提供了只包含一个compareTo()方法的Comparable接口，这个方法可以给两个对象排序。具体来说，它返回负数，0，正数，表示输入对象小于，等于，大于已经存在的对象。</p>
<p>Java提供了包含compare()和equals()两个方法的Comparator接口，compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作参数，它用来决定输入参数是否和comparator相同。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</p>
<h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p>HashSet是用Hash表来实现的，因此他的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。<br>另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/30/Java面试题总结/" data-id="cjj1fz1k0000es0hed1a1umx7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程之间的通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/Java多线程之间的通信/" class="article-date">
  <time datetime="2018-06-30T13:26:29.303Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/Java多线程之间的通信/">Java多线程之间的通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>很多时候要让多个线程按照一定次序来访问共享资源需要考虑同步问，我们使用synchronized关键字，但是仅仅是synchronized关键字是不够的，虽然synchronized关键字可以阻止并发更新同一个共享资源，实现同步，但是却不能用来实现线程间的通信。  </p>
<p>Java提供了三个非常重要的方法：wait(),notify(),notifyall()。他们都继承于Object对象。</p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><p>调用wait()方法可以使调用该方法的线程释放共享资源的锁，然后从线程退出，进入等待队列，直到被再次唤醒。</p>
<h3 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h3><p>调用notify()方法可以唤醒等待队列中的第一个等待同一共享资源的的线程，使得线程退出等待队列，进入可运行状态。  </p>
<h3 id="notify-1"><a href="#notify-1" class="headerlink" title="notify()"></a>notify()</h3><p>调用notifyall()方法可以唤醒在等待队列中等待同一共享资源的的线程从等待队列中退出，进入可运行状态。</p>
<p><strong>通过共享对象通信</strong><br><strong>管道流</strong><br>线程通信使用管道流，管道流有3种形式：        PipedInputStream、PipedOutputStream、PipedReader和PipedWriter以及Pipe.SinkChannel和Pipe.SourceChannel，</p>
<p>它们分别是管道流的字节流、管道字符流和新IO的管道Channel。</p>
<p>管道流通信基本步骤：</p>
<pre><code>A、使用new操作法来创建管道输入、输出流

B、使用管道输入流、输出流的connect方法把2个输入、输出流连接起来

C、将管道输入、输出流分别传入2个线程

D、2个线程可以分别依赖各自的管道输入流、管道输出流进行通
</code></pre><p>为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？</p>
<p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/30/Java多线程之间的通信/" data-id="cjj1fz1jl000ds0he92l4b4yf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java反射机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/Java反射机制/" class="article-date">
  <time datetime="2018-06-30T13:26:29.300Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>什么是反射</strong>  </p>
<p>Java反射机制允许程序在运行状态对自身进行检查，或者自审，并且能直接操作程序的内部属性和方法。反射机制是Java被视为动态语言的关键。允许程序执行期通过Reflection APIs取得任何一支名称的类的内部信息，包括package，type parameters，superclass，implemented interfaces，inner classes，outer class,fields,constructors,methods,modifiers,并可以在执行期生成实例，变更field，或者调用方法。  </p>
<p><strong>Java反射中需要的类</strong><br>Java的类反射所需要的类不多，分别是Field，Constructor，Method，Class，Object。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/30/Java反射机制/" data-id="cjj1fz1jk000cs0hetzp6nt36" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java-多态和重载" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/Java-多态和重载/" class="article-date">
  <time datetime="2018-06-30T13:26:29.296Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/Java-多态和重载/">Java-多态和重载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指子类重新定义父类的虚方法。子类重新定义父类的虚方法以后，父类根据赋给他的不同子类动态调用属于子类的该方法，这样的方法调用在编译期是无法确定的。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载是允许存在多个同名方法，而方法的参数不同 (不同参数个数，不同类型，不同参数顺序)。 编译器根据方法不同的参数表，对同名方法的名称做修饰。对编译器而言，同名的方法会成为不同的方法。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>两者的区别在于能否在编译期确定所要调用的具体方法。所以重载叫做“早绑定”和“静态绑定”，多态又叫“晚绑定”和“动态绑定”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/30/Java-多态和重载/" data-id="cjj1fz1ji000bs0he6op5cw03" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/30/新学的一点JS技巧/">分享一个JS技巧</a>
          </li>
        
          <li>
            <a href="/2018/06/30/基于手机解锁的智能锁设计/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/06/30/关于邮件附件名为中文时的问题处理/">邮件附件名为中文时收到的邮件附件为tcmime.XXXX.XXXX.XXXX.bin</a>
          </li>
        
          <li>
            <a href="/2018/06/30/Spark入门/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/06/30/QuickSort/">快速排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>