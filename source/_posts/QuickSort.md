title: AngularMVC基础
---

### 快速排序  
快速排序可能是运用最广泛的排序算法，主要原因是他实现简单，适用于各种输入数据，并且在一般应用中比其他排序算法快得多。  
主要特点：原地排序，且将长度为N的数组排序所需时间和NlogN成正比，快速排序内循环比大多数哦爱婿算法都要短小，所以更加快速。  
主要缺点：非常脆弱，在实际使用中，要非常小心才能避免低劣的性能。  

快速排序是一种分治的排序算法，他将数组分成两个子数组，将两个部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分为两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。归并排序中先归并再排序，快速排序中线排序在归并。  

快速排序的关键在于切分，使得数组满足如下条件：  
  
- 对于某个j，a[j]已经排定；
- a[lo]到a[j-1]中的所有元素都不大于a[j];
- a[j+1]到a[hi]中的所有元素都不小于a[i];  

因为切分的过程总能排定一个元素，用归纳法可以证明递归能够正确地将数组排序：如果左子元素和右子元素都是有序的，那么由左子元素，切分元素和右子元素组成的结果数组一定是有序的。  

在快速排序中需要实现切分方法。一般策略是先随机地取a[lo]作为切分元素，即那个将要被排定的元素，然后我们从左端开始向右扫描直到找到一个大于等于它的元素，再从数组右边向左开始扫描知道找到一个小于等于它的元素。这两个元素显然没有排定，因此我们交换他们的位置。如此继续就可以保证左指针左侧的元素不大于切分元素，右指针右侧的元素不小于切分元素。当两个指针相遇，我们只需要将切分元素a[lo]和左子数组最右侧的元素a[j]交换然后返回j即可。  

以下是在快速排序中的几个细节问题，因为他们都可能导致实现错误或是影响性能。   
**原地切分**  
如果使用辅助数组将会很容易实现切分，凡是切分后的数组复制回去的开销也会让我们得不偿失。如果将空数组创建在递归方法中，会大大降低排序的性能。  
**别越界**  
如果切分元素是数组中最小或者是最大的元素，我们要小心别然扫描指针抛出数组边界。partition()实现可以进行明确的检测来预防这种情况。测试条件（j==lo）是冗余的，因为切分元素就是a[lo],他不可能比自己小。数组右端也有相同的情况，他们都是可以去掉的。  
**保持随机性**  
数组元素被打乱过，对于预测算法时间很重要。另一种保持随机性的方法就是在partition()方法中随机选择一个切分元素。  
**终止循环**  
有经验的程序员都知道保证循环结束需要格外小心，快速排序的切分循环也不例外。正确地检测指针是否越界需要一点技巧。一个常见的错误就是没有考虑到数组中可能包含和切分元素相同的其他元素。  
**处理切分元素值有重复的情况**  
如算法所示，左侧扫描最好实在遇到大于等于切分元素值得元素时停下，右侧扫描则是遇到小于等于切分元素的值的元素时停下。尽管这样可能会不必要德将一些等值的元素交换，但是在某些典型应用中，他能避免算法的运行时间变为平方级。  
**终止递归**  
保证递归的正确结束也是需要格外小心的，快速排序也不例外，实现快速排序的一个常见错误就是不能保证切分元素放入正确位置，从而导致程序在切分元素正好是子数组的最大或者是最小元素时陷入无限递归循环之中。

#### 性能特点  
快速排序切分方法内循环比其他排序算法短小，只需要用一个递增的索引将数组元素与一个定值比较，简洁的内循环使得算法更加高效。  
另一个优势在于，比较次数较少，排序效率最终还是依赖于切分数组的效果，而这还是依赖于切分点的值。  
快速排序最好的情况是每次正好能将数组对半分。在这种情况下快速排序所用的比较次数正好满足分治递归的`Cn=2Cn\2+N`公式。2Cn/2表示将两个子数组排序的成本，N表示切分元素和所有数组元素进行比较的成本。由归并排序的命题F证明可知，这个递归公式的解Cn~Nlogn.尽管事情进行总不会那么顺利，但是平均而言切分元素都能落在数组中间。  
尽管快速排序有很多优点，它的基本实现却有一个潜在的缺点，在切分不平衡时这个程序可能会极为低效。例如，第一次从最小的元素切分，第二次从第二小的元素切分，这样每次调用只会移除一个元素。这会导致一个大子数组需要切分很多次。我们要在排序前将数组随机排序主要的原因就是避免这种情况。  

###算法改进 
如果你的排序算法会被执行很多次，或者会被用在大型数组上，下面这些改进意见值得参考。  
**切换到插入排序**  
和大多数算法改进一样，改进快速排序性能的简单办法基于以下两点：  


- 对于小数组快速排序比插入排序慢  
- 因为递归，快速排序的sort()在小数组中也会调用自己  

将sort()函数中的语句  
	

    if （hi <= lo) return;
替换成如下语句来对小数组使用插入排序  
    
    if (hi <= lo +m) {Insertion.sort(a, lo, hi); return;} 

转换参数m的最佳值是和系统有关的，但是5~15之间的任何值都能令人满意。  

**三取样切分**  
改进快速排序性能的第二个方法就是使用子数组的一小部分元素的中位数来切分数组，但是这样做的代价就是需要计算中位数。人们发现将取样大小设为3并且用大小居中的元素切分的效果更好。我们还可以经取样元素放在数组末尾作为哨兵来去掉partition（）边界测试。  

**熵最优的排序**  
实际应用中经常会有大量重复的元素，对于重复的数组，算法还是会进行划分，还有很大的改进空间。一个简单的想法就是将数组切分为三部分，分别对应于小于，等于和大于切分元素的数组元素。这种切分比当前的二分法更加复杂。